import { setTimeout } from "node:timers/promises";
export class WebSocketManager {
    #dispatch;
    #debug;
    #sequenceNumber = null;
    #isResuming = false;
    #ws;
    #gatewayInfo;
    #options;
    #timer;
    #gotACK = true;
    resumeInfo = {};
    constructor(options, dispatch, debug) {
        if (!options.intents)
            throw new Error("No intents were passed");
        this.#dispatch = dispatch;
        this.#debug = debug;
        this.#options = options;
    }
    close() {
        this.#ws.close(1000);
    }
    async connect(url) {
        if (typeof this.#gatewayInfo === "undefined") {
            const response = await fetch("https://discord.com/api/v10/gateway/bot", {
                headers: {
                    Authorization: `Bot ${this.#options.token}`
                }
            });
            if (!response.ok)
                throw new Error("An invalid Token was provided");
            const data = await response.json();
            data.url = `${data.url}/?v=10&encoding=json`;
            this.#gatewayInfo = data;
        }
        this.#ws = new WebSocket(url ?? this.#gatewayInfo.url);
        this.#ws.addEventListener("error", (err) => {
            this.#debug?.("ERROR", err);
        });
        this.#ws.addEventListener("close", async ({ code }) => {
            this.#clearTimer();
            if (typeof code === "undefined" || code === 1001 || closeCodeAllowsReconnection(code)) {
                await this.#attemptResume();
                return;
            }
            this.#debug?.("UNKNOWN_CODE", code);
            this.#isResuming = false;
            await this.connect();
        });
        this.#ws.addEventListener("message", (event) => {
            this.#debug?.("WS_MESSAGE", event.data);
            const payload = JSON.parse(event.data.toString());
            if (typeof payload.s === "number")
                this.#sequenceNumber = payload.s;
            switch (payload.op) {
                case 0: {
                    this.#dispatch(payload);
                    break;
                }
                case 10: {
                    const interval = Math.round(payload.d.heartbeat_interval * Math.random());
                    this.#startTimer(interval);
                    if (!this.#isResuming)
                        this.#identify();
                    else
                        this.#resume();
                    break;
                }
                case 1: {
                    this.#debug?.("NEED_HEARTBEAT");
                    this.#sendHeartbeatPayload();
                    break;
                }
                case 7: {
                    this.#debug?.("RECONNECT");
                    this.#ws.close(1001);
                    break;
                }
                case 9: {
                    this.#debug?.("INVALID_SESSION");
                    if (payload.d)
                        this.#ws.close(1001);
                    else
                        this.#ws.close(1000);
                    break;
                }
                case 11: {
                    this.#gotACK = true;
                    this.#debug?.("ACK");
                    break;
                }
                default:
                    break;
            }
            return;
        });
    }
    #sendHeartbeatPayload() {
        this.#gotACK = false;
        this.#ws.send(`{ "op": 1, "d": ${this.#sequenceNumber}, "s": null, "t": null }`);
    }
    #identify() {
        if (typeof this.#options.token === "undefined")
            throw new Error("No token was found");
        const payload = {
            op: 2,
            d: {
                token: this.#options.token,
                intents: this.#options.intents,
                properties: {
                    os: process.platform,
                    browser: "LilyBird",
                    device: "LilyBird"
                },
                presence: this.#options.presence
            },
            s: null,
            t: null
        };
        this.#debug?.("IDENTIFY");
        this.#ws.send(JSON.stringify(payload));
    }
    #resume() {
        const payload = {
            op: 6,
            d: {
                token: this.#options.token,
                session_id: this.resumeInfo.id,
                seq: this.#sequenceNumber ?? 0
            },
            s: null,
            t: null
        };
        this.#debug?.("RESUME");
        this.#ws.send(JSON.stringify(payload));
    }
    #startTimer(interval) {
        this.#gotACK = true;
        this.#timer = setInterval(async () => {
            if (!this.#gotACK) {
                this.#debug?.("MISSING_ACK");
                await setTimeout(500);
                if (!this.#gotACK) {
                    this.#debug?.("ZOMBIE");
                    this.#ws.close(1001);
                    return;
                }
            }
            this.#debug?.("HEARTBEAT");
            this.#sendHeartbeatPayload();
        }, interval);
    }
    #clearTimer() {
        if (typeof this.#timer === "undefined")
            return;
        clearInterval(this.#timer);
    }
    async #attemptResume() {
        this.#debug?.("ATTEMPTING_RESUME");
        this.#isResuming = true;
        await this.connect(`${this.resumeInfo.url}/?v=10&encoding=json`);
    }
    async ping() {
        return new Promise((res) => {
            this.#ws.addEventListener("pong", () => {
                res(Math.round(performance.now() - start));
            }, { once: true });
            const start = performance.now();
            this.#ws.ping();
        });
    }
    updatePresence(presence) {
        const options = {
            op: 3,
            d: presence,
            s: null,
            t: null
        };
        this.#ws.send(JSON.stringify(options));
    }
    set options(options) {
        this.#options = { ...this.#options, ...options };
    }
    get options() {
        return this.#options;
    }
}
function closeCodeAllowsReconnection(code) {
    return code >= 4000 && code !== 4004 && code < 4010;
}
