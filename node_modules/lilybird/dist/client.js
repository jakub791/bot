import { ThreadChannel, channelFactory } from "./factories/channel.js";
import { interactionFactory } from "./factories/interaction.js";
import { GuildMember } from "./factories/guild-member.js";
import { guildFactory } from "./factories/guild.js";
import { Message } from "./factories/message.js";
import { User } from "./factories/user.js";
import { REST } from "./http/rest.js";
import { WebSocketManager } from "#ws";
export class Client {
    rest = new REST();
    #ws;
    constructor(res, options, debug) {
        if (Array.isArray(options.intents))
            options.intents = options.intents.reduce((prev, curr) => prev | curr, 0);
        this.#ws = new WebSocketManager({
            intents: options.intents,
            presence: options.presence
        }, async (data) => {
            await options.listeners.raw?.(data.d);
            switch (data.t) {
                case "READY": {
                    Object.assign(this, {
                        user: new User(this, data.d.user),
                        guilds: data.d.guilds,
                        sessionId: data.d.session_id,
                        application: data.d.application
                    });
                    Object.assign(this.#ws.resumeInfo, {
                        url: data.d.resume_gateway_url,
                        id: data.d.session_id
                    });
                    await options.setup?.(this);
                    res(this);
                    await options.listeners.ready?.(this, data.d);
                    break;
                }
                case "RESUMED": {
                    await options.listeners.resumed?.(this);
                    break;
                }
                case "CHANNEL_CREATE": {
                    await options.listeners.channelCreate?.(channelFactory(this, data.d));
                    break;
                }
                case "CHANNEL_UPDATE": {
                    await options.listeners.channelUpdate?.(channelFactory(this, data.d));
                    break;
                }
                case "CHANNEL_DELETE": {
                    await options.listeners.channelDelete?.(channelFactory(this, data.d));
                    break;
                }
                case "CHANNEL_PINS_UPDATE": {
                    await options.listeners.channelPinsUpdate?.(data.d.guild_id, data.d.channel_id, typeof data.d.last_pin_timestamp === "string" ? new Date(data.d.last_pin_timestamp) : null);
                    break;
                }
                case "THREAD_CREATE": {
                    await options.listeners.threadCreate?.(channelFactory(this, data.d));
                    break;
                }
                case "THREAD_UPDATE": {
                    await options.listeners.threadUpdate?.(channelFactory(this, data.d));
                    break;
                }
                case "THREAD_DELETE": {
                    await options.listeners.threadDelete?.(new ThreadChannel(this, data.d, false));
                    break;
                }
                case "GUILD_CREATE": {
                    await options.listeners.guildCreate?.(guildFactory(this, data.d));
                    break;
                }
                case "GUILD_UPDATE": {
                    await options.listeners.guildUpdate?.(guildFactory(this, data.d));
                    break;
                }
                case "GUILD_DELETE": {
                    await options.listeners.guildDelete?.(data.d);
                    break;
                }
                case "GUILD_MEMBER_ADD": {
                    await options.listeners.guildMemberAdd?.(new GuildMember(this, data.d));
                    break;
                }
                case "GUILD_MEMBER_REMOVE": {
                    await options.listeners.guildMemberRemove?.(data.d.guild_id, new User(this, data.d.user));
                    break;
                }
                case "GUILD_MEMBER_UPDATE": {
                    await options.listeners.guildMemberUpdate?.(new GuildMember(this, data.d));
                    break;
                }
                case "INTERACTION_CREATE": {
                    await options.listeners.interactionCreate?.(interactionFactory(this, data.d));
                    break;
                }
                case "INVITE_CREATE": {
                    await options.listeners.inviteCreate?.(data.d);
                    break;
                }
                case "INVITE_DELETE": {
                    await options.listeners.inviteDelete?.(data.d);
                    break;
                }
                case "MESSAGE_CREATE": {
                    await options.listeners.messageCreate?.(new Message(this, data.d));
                    break;
                }
                case "MESSAGE_UPDATE": {
                    await options.listeners.messageUpdate?.(new Message(this, data.d));
                    break;
                }
                case "MESSAGE_DELETE": {
                    await options.listeners.messageDelete?.(new Message(this, data.d));
                    break;
                }
                case "MESSAGE_DELETE_BULK": {
                    await options.listeners.messageDeleteBulk?.(data.d);
                    break;
                }
                case "PRESENCE_UPDATE": {
                    await options.listeners.presenceUpdate?.(data.d);
                    break;
                }
                case "USER_UPDATE": {
                    await options.listeners.userUpdate?.(new User(this, data.d));
                    break;
                }
                default:
            }
        }, debug);
    }
    async login(token) {
        this.#ws.options = { token };
        this.rest.setToken(token);
        await this.#ws.connect();
        return token;
    }
    close() {
        this.rest.setToken(undefined);
        this.#ws.close();
    }
    setPresence(presence) {
        this.#ws.updatePresence(presence);
    }
    async ping() {
        const start = performance.now();
        await this.rest.getGateway();
        const final = Math.floor(performance.now() - start);
        return {
            ws: await this.#ws.ping(),
            rest: final
        };
    }
}
export async function createClient(options) {
    return new Promise((res) => {
        new Client(res, { intents: options.intents, listeners: options.listeners, setup: options.setup }, options.attachDebugListener
            ? options.debugListener ?? ((identifier, payload) => {
                console.log(identifier, payload ?? "");
            })
            : undefined).login(options.token);
    });
}
